#!/usr/bin/env python3
"""
Test runner for TLS certificate tests
"""

import os
import sys
import subprocess
import glob
import argparse
import re
from pathlib import Path

# Colors
GREEN = '\033[0;32m'
RED = '\033[0;31m'
YELLOW = '\033[1;33m'
BLUE = '\033[1;36m'  # Bright Cyan
NC = '\033[0m'  # No Color

TERMINAL_WIDTH = 80

# Load error codes
ERROR_CODES = {}
def load_error_codes():
    """Load error codes from err_code file"""
    global ERROR_CODES
    script_dir = os.path.dirname(os.path.abspath(__file__))
    err_code_file = os.path.join(script_dir, 'err_code')
    
    try:
        with open(err_code_file, 'r') as f:
            content = f.read()
            # Parse error codes from bash array format
            matches = re.findall(r'\[(\d+)\]="([^"]+)"', content)
            for code, desc in matches:
                ERROR_CODES[int(code)] = desc
    except Exception as e:
        print(f"{YELLOW}Warning: Could not load error codes: {e}{NC}")

load_error_codes()


def get_test_name(filepath):
    """Convert test filename to display name"""
    basename = os.path.basename(filepath)
    # Remove 'test_' prefix
    name = basename.replace('test_', '')
    # Convert _ to space and uppercase
    name = name.replace('_', ' ').upper()
    return f"#TEST {name}"


def extract_commands(test_file):
    """Extract openssl commands from test file"""
    commands = []
    try:
        with open(test_file, 'r') as f:
            content = f.read()
            lines = content.split('\n')
            
            i = 0
            while i < len(lines):
                line = lines[i].strip()
                # Look for openssl commands
                if 'openssl' in line:
                    cmd_parts = [line]
                    # Check for line continuations
                    while i < len(lines) - 1 and lines[i].rstrip().endswith('\\'):
                        i += 1
                        continuation = lines[i].strip()
                        if continuation and not continuation.startswith('#'):
                            cmd_parts.append(continuation)
                    
                    # Join and clean up the command
                    full_cmd = ' '.join(cmd_parts)
                    # Remove cmd=$( and trailing )
                    full_cmd = full_cmd.replace('cmd=$(', '').replace('<<< "Q" 2>&1)', '').rstrip(')')
                    # Remove backslashes and extra spaces
                    full_cmd = full_cmd.replace('\\', '').strip()
                    # Normalize spaces
                    full_cmd = ' '.join(full_cmd.split())
                    
                    if full_cmd:
                        commands.append(full_cmd)
                i += 1
    except Exception:
        pass
    
    return commands


def get_expected_error_code(test_file):
    """Extract expected error code from test file comment"""
    try:
        with open(test_file, 'r') as f:
            for line in f:
                # Look for "Expected: error code X" in comments
                match = re.search(r'#.*Expected:\s*error\s*code\s*(\d+)', line, re.IGNORECASE)
                if match:
                    return int(match.group(1))
    except Exception:
        pass
    return None


def extract_error_codes(output):
    """Extract all unique error codes from openssl output"""
    error_codes = []
    
    # Look for all "verify error:num=X" occurrences
    matches = re.findall(r'verify error:num=(\d+)', output)
    for match in matches:
        code = int(match)
        if code not in error_codes:
            error_codes.append(code)
    
    # If no verify errors found, check for "Verify return code: X"
    if not error_codes:
        match = re.search(r'Verify return code:\s*(\d+)', output)
        if match:
            error_codes.append(int(match.group(1)))
    
    # If still nothing, check for "Verification: OK" (error code 0)
    if not error_codes and re.search(r'Verification:\s*OK', output, re.IGNORECASE):
        error_codes.append(0)
    
    return error_codes if error_codes else None


def run_test(test_file, detail=False, show_commands=False):
    """Run a single test file and return result"""
    test_name = get_test_name(test_file)
    expected_error = get_expected_error_code(test_file)
    
    try:
        # Run the test script
        result = subprocess.run(
            ['bash', test_file],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Extract actual error codes from output (can be multiple)
        actual_errors = extract_error_codes(result.stdout)
        
        # Determine if test passed
        test_passed = False
        if expected_error is not None:
            # We have an expected error code, check if it's in the list of actual errors
            if actual_errors:
                test_passed = (expected_error in actual_errors)
            else:
                test_passed = False
        else:
            # No expected error specified, use exit code
            test_passed = (result.returncode == 0)
        
        # Format actual errors for display
        actual_error_str = None
        if actual_errors:
            error_descriptions = []
            for code in actual_errors:
                if code in ERROR_CODES:
                    error_descriptions.append(f"{code} - {ERROR_CODES[code]}")
                else:
                    error_descriptions.append(str(code))
            actual_error_str = ", ".join([str(c) for c in actual_errors])
            actual_error_desc = " | ".join(error_descriptions)
        
        # Print result
        if test_passed:
            # PASS
            print(f"{test_name:<{TERMINAL_WIDTH-6}}{GREEN}[PASS]{NC}")
            if show_commands:
                commands = extract_commands(test_file)
                for cmd in commands:
                    print(f"    {cmd}")
            if detail:
                if expected_error is not None and expected_error in ERROR_CODES:
                    print(f"    Expected: {expected_error} - {ERROR_CODES[expected_error]}")
                if actual_errors:
                    # Print first error on same line, rest indented
                    for i, code in enumerate(actual_errors):
                        if code in ERROR_CODES:
                            desc = ERROR_CODES[code]
                        else:
                            desc = "Unknown error"
                        if i == 0:
                            print(f"    Actual Error: {code} - {desc}")
                        else:
                            print(f"                  {code} - {desc}")
                
                print('')    
                if result.stdout:
                    for line in result.stdout.strip().split('\n')[:10]:  # Limit to first 10 lines
                        if line.strip() and ('verify' in line.lower() or 'depth=' in line):
                            print(f"    {line}")
            return True
        else:
            # FAIL
            print(f"{test_name:<{TERMINAL_WIDTH-6}}{RED}[FAIL]{NC}")
            if show_commands:
                commands = extract_commands(test_file)
                for cmd in commands:
                    print(f"    {cmd}")
            
            # Print error information
            if expected_error is not None:
                if expected_error in ERROR_CODES:
                    print(f"    Expected Error: {expected_error} - {ERROR_CODES[expected_error]}")
                else:
                    print(f"    Expected Error Code: {expected_error}")
                    
            if actual_errors:
                # Print first error on same line, rest indented
                for i, code in enumerate(actual_errors):
                    if code in ERROR_CODES:
                        desc = ERROR_CODES[code]
                    else:
                        desc = "Unknown error"
                    if i == 0:
                        print(f"    Actual Error: {code} - {desc}")
                    else:
                        print(f"                  {code} - {desc}")
            else:
                print(f"    No error code found in output")
                print(f"    Exit code: {result.returncode}")
            
            # Print relevant output lines
            if result.stdout:
                for line in result.stdout.strip().split('\n')[:15]:
                    if line.strip() and ('verify' in line.lower() or 'error' in line.lower() or 'depth=' in line):
                        print(f"    {line}")
            
            if result.stderr:
                for line in result.stderr.strip().split('\n')[:10]:
                    if line.strip():
                        print(f"    {line}")
            return False
        
    except subprocess.TimeoutExpired:
        print(f"{test_name:<{TERMINAL_WIDTH-6}}{RED}[FAIL]{NC}")
        print(f"    Description: Test timeout (30s)")
        return False
    except Exception as e:
        print(f"{test_name:<{TERMINAL_WIDTH-6}}{RED}[FAIL]{NC}")
        print(f"    Description: {str(e)}")
        return False


def find_all_tests(directory=None):
    """Find all test files in directory"""
    if directory is None:
        # Use the script's directory if not specified
        directory = os.path.dirname(os.path.abspath(__file__))
    pattern = os.path.join(directory, 'test_*')
    tests = glob.glob(pattern)
    # Filter out directories and only keep files
    tests = [t for t in tests if os.path.isfile(t)]
    # Sort alphanumerically
    tests.sort()
    return tests


def list_tests():
    """List all available test files"""
    tests = find_all_tests()
    if not tests:
        print(f"{YELLOW}No test files found{NC}")
        return
    
    print(f"\n{BLUE}{'='*TERMINAL_WIDTH}{NC}")
    print(f"{BLUE}Available Tests ({len(tests)} total){NC}")
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")
    
    for i, test in enumerate(tests, 1):
        basename = os.path.basename(test)
        test_name = get_test_name(test)
        print(f"  {i}. {basename}")
        print(f"     {test_name}\n")
    
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")


def create_parser():
    """Create and configure argument parser"""
    parser = argparse.ArgumentParser(
        description='TLS Certificate Test Runner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f'''
{YELLOW}Examples:{NC}
  python tls                                    Run all tests
  python tls --list                             List all available tests
  python tls test_02_complete_chain             Run a specific test
  python tls --detail                           Run all tests with detailed output
  python tls --within-commands                  Show commands executed in tests
  python tls test_02_complete_chain --detail --within-commands
                                                Run specific test with all options
        '''
    )
    
    parser.add_argument(
        'test_file',
        nargs='?',
        help='Specific test file to run (optional)'
    )
    
    parser.add_argument(
        '--list',
        action='store_true',
        help='List all available test files and exit'
    )
    
    parser.add_argument(
        '--detail',
        action='store_true',
        help='Show detailed output from test execution'
    )
    
    parser.add_argument(
        '--within-commands',
        action='store_true',
        help='Show the commands executed within each test'
    )
    
    return parser





def main():
    """Main test runner"""
    # Parse arguments
    parser = create_parser()
    args = parser.parse_args()
    
    # Handle --list flag
    if args.list:
        list_tests()
        sys.exit(0)
    
    # Determine which tests to run
    if args.test_file:
        # Run specific test
        if not os.path.exists(args.test_file):
            print(f"{RED}Error: Test file '{args.test_file}' not found{NC}")
            sys.exit(1)
        tests = [args.test_file]
    else:
        # Run all tests
        tests = find_all_tests()
        if not tests:
            print(f"{YELLOW}No test files found{NC}")
            sys.exit(0)
    
    # Print header
    print(f"\n{BLUE}{'='*TERMINAL_WIDTH}{NC}")
    print(f"{BLUE}Running {len(tests)} test(s){NC}")
    if args.detail:
        print(f"{BLUE}Detail mode: ON{NC}")
    if args.within_commands:
        print(f"{BLUE}Show commands: ON{NC}")
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")
    
    # Run tests
    results = []
    for test in tests:
        passed = run_test(test, detail=args.detail, show_commands=args.within_commands)
        results.append((test, passed))
        print()  # Empty line between tests
    
    # Print summary
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}")
    passed_count = sum(1 for _, passed in results if passed)
    failed_count = len(results) - passed_count
    
    print(f"{BLUE}Test Summary")
    print(f"    {GREEN}Passed: {passed_count}{NC}")
    print(f"    {RED}Failed: {failed_count}{NC}")
    print(f"-------------")
    print(f"    Total:  {len(results)} Test Cases")
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")
    
    # Exit with error if any test failed
    sys.exit(0 if failed_count == 0 else 1)


if __name__ == '__main__':
    main()
