#!/usr/bin/env python3
"""
Test runner for TLS certificate tests
"""

import os
import sys
import subprocess
import glob
import argparse
from pathlib import Path

# Colors
GREEN = '\033[0;32m'
RED = '\033[0;31m'
YELLOW = '\033[1;33m'
BLUE = '\033[1;36m'  # Bright Cyan
NC = '\033[0m'  # No Color

TERMINAL_WIDTH = 80


def get_test_name(filepath):
    """Convert test filename to display name"""
    basename = os.path.basename(filepath)
    # Remove 'test_' prefix
    name = basename.replace('test_', '')
    # Convert _ to space and uppercase
    name = name.replace('_', ' ').upper()
    return f"#TEST {name}"


def extract_commands(test_file):
    """Extract openssl commands from test file"""
    commands = []
    try:
        with open(test_file, 'r') as f:
            content = f.read()
            lines = content.split('\n')
            
            i = 0
            while i < len(lines):
                line = lines[i].strip()
                # Look for openssl commands
                if 'openssl' in line:
                    cmd_parts = [line]
                    # Check for line continuations
                    while i < len(lines) - 1 and lines[i].rstrip().endswith('\\'):
                        i += 1
                        continuation = lines[i].strip()
                        if continuation and not continuation.startswith('#'):
                            cmd_parts.append(continuation)
                    
                    # Join and clean up the command
                    full_cmd = ' '.join(cmd_parts)
                    # Remove cmd=$( and trailing )
                    full_cmd = full_cmd.replace('cmd=$(', '').replace('<<< "Q" 2>&1)', '').rstrip(')')
                    # Remove backslashes and extra spaces
                    full_cmd = full_cmd.replace('\\', '').strip()
                    # Normalize spaces
                    full_cmd = ' '.join(full_cmd.split())
                    
                    if full_cmd:
                        commands.append(full_cmd)
                i += 1
    except Exception:
        pass
    
    return commands


def run_test(test_file, detail=False, show_commands=False):
    """Run a single test file and return result"""
    test_name = get_test_name(test_file)
    
    try:
        # Run the test script
        result = subprocess.run(
            ['bash', test_file],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Check if test passed (exit code 0)
        if result.returncode == 0:
            # PASS
            print(f"{test_name:<{TERMINAL_WIDTH-6}}{GREEN}[PASS]{NC}")
            if show_commands:
                commands = extract_commands(test_file)
                for cmd in commands:
                    print(f"    {cmd}", end='\n\n')
            if detail and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        print(f"    {line}")
            return True
        else:
            # FAIL
            print(f"{test_name:<{TERMINAL_WIDTH-6}}{RED}[FAIL]{NC}")
            if show_commands:
                commands = extract_commands(test_file)
                for cmd in commands:
                    print(f"    {cmd}")
            # Print failure details with indent
            if result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        print(f"    {line}")
            if result.stderr:
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        print(f"    {line}")
            return False
            
    except subprocess.TimeoutExpired:
        print(f"{test_name:<{TERMINAL_WIDTH-6}}{RED}[FAIL]{NC}")
        print(f"    Description: Test timeout (30s)")
        return False
    except Exception as e:
        print(f"{test_name:<{TERMINAL_WIDTH-6}}{RED}[FAIL]{NC}")
        print(f"    Description: {str(e)}")
        return False


def find_all_tests(directory=None):
    """Find all test files in directory"""
    if directory is None:
        # Use the script's directory if not specified
        directory = os.path.dirname(os.path.abspath(__file__))
    pattern = os.path.join(directory, 'test_*')
    tests = glob.glob(pattern)
    # Filter out directories and only keep files
    tests = [t for t in tests if os.path.isfile(t)]
    # Sort alphanumerically
    tests.sort()
    return tests


def list_tests():
    """List all available test files"""
    tests = find_all_tests()
    if not tests:
        print(f"{YELLOW}No test files found{NC}")
        return
    
    print(f"\n{BLUE}{'='*TERMINAL_WIDTH}{NC}")
    print(f"{BLUE}Available Tests ({len(tests)} total){NC}")
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")
    
    for i, test in enumerate(tests, 1):
        basename = os.path.basename(test)
        test_name = get_test_name(test)
        print(f"  {i}. {basename}")
        print(f"     {test_name}\n")
    
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")


def create_parser():
    """Create and configure argument parser"""
    parser = argparse.ArgumentParser(
        description='TLS Certificate Test Runner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f'''
{YELLOW}Examples:{NC}
  python tls                                    Run all tests
  python tls --list                             List all available tests
  python tls test_02_complete_chain             Run a specific test
  python tls --detail                           Run all tests with detailed output
  python tls --within-commands                  Show commands executed in tests
  python tls test_02_complete_chain --detail --within-commands
                                                Run specific test with all options
        '''
    )
    
    parser.add_argument(
        'test_file',
        nargs='?',
        help='Specific test file to run (optional)'
    )
    
    parser.add_argument(
        '--list',
        action='store_true',
        help='List all available test files and exit'
    )
    
    parser.add_argument(
        '--detail',
        action='store_true',
        help='Show detailed output from test execution'
    )
    
    parser.add_argument(
        '--within-commands',
        action='store_true',
        help='Show the commands executed within each test'
    )
    
    return parser





def main():
    """Main test runner"""
    # Parse arguments
    parser = create_parser()
    args = parser.parse_args()
    
    # Handle --list flag
    if args.list:
        list_tests()
        sys.exit(0)
    
    # Determine which tests to run
    if args.test_file:
        # Run specific test
        if not os.path.exists(args.test_file):
            print(f"{RED}Error: Test file '{args.test_file}' not found{NC}")
            sys.exit(1)
        tests = [args.test_file]
    else:
        # Run all tests
        tests = find_all_tests()
        if not tests:
            print(f"{YELLOW}No test files found{NC}")
            sys.exit(0)
    
    # Print header
    print(f"\n{BLUE}{'='*TERMINAL_WIDTH}{NC}")
    print(f"{BLUE}Running {len(tests)} test(s){NC}")
    if args.detail:
        print(f"{BLUE}Detail mode: ON{NC}")
    if args.within_commands:
        print(f"{BLUE}Show commands: ON{NC}")
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")
    
    # Run tests
    results = []
    for test in tests:
        passed = run_test(test, detail=args.detail, show_commands=args.within_commands)
        results.append((test, passed))
        print()  # Empty line between tests
    
    # Print summary
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}")
    passed_count = sum(1 for _, passed in results if passed)
    failed_count = len(results) - passed_count
    
    print(f"{BLUE}Test Summary")
    print(f"    {GREEN}Passed: {passed_count}{NC}")
    print(f"    {RED}Failed: {failed_count}{NC}")
    print(f"-------------")
    print(f"    Total:  {len(results)} Test Cases")
    print(f"{BLUE}{'='*TERMINAL_WIDTH}{NC}\n")
    
    # Exit with error if any test failed
    sys.exit(0 if failed_count == 0 else 1)


if __name__ == '__main__':
    main()
